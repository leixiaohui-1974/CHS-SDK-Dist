from core_lib.core.interfaces import PhysicalObjectInterface, State
from core_lib.central_coordination.collaboration.message_bus import MessageBus, Message
from typing import Optional, Dict, Any

class WaterTurbine(PhysicalObjectInterface):
    """
    Represents a water turbine for hydropower generation.

    This model calculates the power generated based on the flow rate and
    hydraulic head difference. It can be controlled by setting a target outflow
    via the message bus.

    State Variables:
        - outflow (float): The flow of water passing through the turbine (m^3/s).
        - power (float): The electrical power generated by the turbine (Watts).

    Parameters:
        - efficiency (float): The turbine's conversion efficiency (0.0 to 1.0).
        - max_flow_rate (float): The maximum flow rate the turbine can handle (m^3/s).
    """

    def __init__(self, name: str, initial_state: State, parameters: dict,
                 message_bus: Optional[MessageBus] = None, action_topic: Optional[str] = None,
                 action_key: str = 'target_outflow'):
        super().__init__(name, initial_state, parameters)
        self.efficiency = self._params['efficiency']
        self.max_flow_rate = self._params['max_flow_rate']
        self.rho = 1000  # Density of water in kg/m^3
        self.g = 9.81    # Acceleration of gravity in m/s^2

        # Ensure initial state has required keys
        self._state.setdefault('outflow', 0.0)
        self._state.setdefault('power', 0.0)

        self.bus = message_bus
        self.action_topic = action_topic
        self.action_key = action_key
        self.target_outflow = self._state.get('outflow', 0.0)

        if self.bus and self.action_topic:
            self.bus.subscribe(self.action_topic, self.handle_action_message)
            print(f"Turbine '{self.name}' subscribed to action topic '{self.action_topic}'.")

    def handle_action_message(self, message: Message):
        """Callback to handle incoming action messages from the bus."""
        if self.action_key in message:
            self.target_outflow = message[self.action_key]

    def step(self, action: dict, dt: float) -> State:
        """
        Calculates the turbine's outflow and power generation for one time step.
        """
        # The harness provides inflow and head information in the action dictionary
        inflow = self._inflow

        # The turbine's outflow is constrained by the available inflow, its max flow rate, and the agent's target.
        # The actual outflow cannot exceed the amount of water coming in.
        outflow = min(inflow, self.max_flow_rate, self.target_outflow)
        self._state['outflow'] = outflow

        # The harness provides head levels from adjacent components
        upstream_head = action.get('upstream_head', 0)
        downstream_head = action.get('downstream_head', 0)

        # Head difference must be positive for power generation
        head = max(0, upstream_head - downstream_head)

        # Calculate power generated using the hydropower equation: P = η * ρ * g * Q * H
        power_watts = self.efficiency * self.rho * self.g * outflow * head
        self._state['power'] = power_watts

        return self.get_state()
